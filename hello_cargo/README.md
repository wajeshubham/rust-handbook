# Start a cargo project & project overview

```bash
$ cargo new hello_cargo
$ cd hello_cargo
```

The first command creates a new directory and project called hello_cargo. We’ve named our project hello_cargo, and Cargo creates its files in a directory of the same name.

Go into the hello_cargo directory and list the files. You’ll see that Cargo has generated two files and one directory for us: a Cargo.toml file and a src directory with a main.rs file inside.

Open Cargo.toml in your text editor of choice. It should look similar to the code in Listing 1-2.

Filename: Cargo.toml

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
Listing 1-2: Contents of Cargo.toml generated by cargo new
```

This file is in the TOML (Tom’s Obvious, Minimal Language) format, which is Cargo’s configuration format.

The first line, `[package]`, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we’ll add other sections.

The next three lines set the configuration information Cargo needs to compile your program: the name, the version, and the edition of Rust to use. We’ll talk about the edition key in Appendix E.

The last line, `[dependencies]`, is the start of a section for you to list any of your project’s dependencies. In Rust, packages of code are referred to as crates. We won’t need any other crates for this project, but we will in the first project in Chapter 2, so we’ll use this dependencies section then.

Now open src/main.rs and take a look:

Filename: src/main.rs

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo has generated a `“Hello, world!”` program for you, just like the one we wrote in `hello_world` folder. So far, the differences between our project and the project Cargo generated are that Cargo placed the code in the src directory and we have a `Cargo.toml` configuration file in the top directory.

# Build the project and run

```bash
$ cargo build
    Compiling hello_cargo v0.1.0 (////rust_projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 1.25s
```

This command creates an executable file in `target/debug/hello_cargo` (or `target\debug\hello_cargo.exe` on `Windows`) rather than in your current directory.

Because the default build is a debug build, Cargo puts the binary in a directory named debug. You can run the executable with this command:

```bash
$ ./target/debug/hello_cargo
Hello, world!
```

If all goes well, `Hello, world!` should print to the terminal. Running cargo build for the first time also causes Cargo to create a new file at the top level: `Cargo.lock`.

This file keeps track of the exact versions of dependencies in your project. This project doesn’t have dependencies, so the file is a bit sparse. You won’t ever need to change this file manually; Cargo manages its contents for you.

# Build command can be eliminated

We just built a project with cargo build and ran it with `./target/debug/hello_cargo`, but we can also use `cargo run` to compile the code and then run the resultant executable all in one command:

```bash
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Using `cargo run` is more convenient than having to remember to run `cargo build` and then use the whole path to the binary, **so most developers use cargo run**.

NOTE: Notice that this time we didn’t see output indicating that Cargo was compiling `hello_cargo`. Cargo figured out that the files hadn’t changed, so it didn’t rebuild but just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it.

# Check if program is compilable

Cargo also provides a command called cargo check. This command quickly checks your code to make sure it compiles but doesn’t produce an executable:

```bash
$ cargo check
   Checking hello_cargo v0.1.0 (////rust_projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Why would you not want an executable? Often, cargo check is much faster than cargo build because it skips the step of producing an executable.

If you’re continually checking your work while writing the code, using cargo check will speed up the process of letting you know if your project is still compiling.

# Recap on cargo

- We can create a project using cargo new.

- We can build a project using cargo build.

- We can build and run a project in one step using cargo run.

- We can build a project without producing a binary to check for errors using cargo check.

- Instead of saving the result of the build in the same directory as our code, Cargo stores it in the `target/debug` directory.

An additional advantage of using Cargo is that the commands are the same no matter which operating system you’re working on.

# Building for Release

When your project is finally ready for release, you can use `cargo build --release` to compile it with optimizations. This command will create an executable in `target/release` instead of `target/debug`.

The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for `development`, when you want to rebuild quickly and often, and another for building the final program you’ll give to a user that won’t be rebuilt repeatedly and that will run as fast as possible.
